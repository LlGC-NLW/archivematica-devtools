#!/usr/bin/env python

from optparse import OptionParser
import sys
import uuid

from main import models

import django
django.setup()

##
## Tool for inspecting microservice chain and rendering SQL for altering it
##

#
# Internal helpers
#

def simple_multi_value_query(qs, field):
    return qs.values_list(field, flat=True)

def simple_value_query(qs, field):
    try:
        return getattr(qs[0], field)
    except IndexError:
        pass

def get_next_link(link_uuid):
    return simple_value_query(models.MicroServiceChainLinkExitCode.objects.filter(microservicechainlink=link_uuid, exitcode=0), 'nextmicroservicechainlink_id')

def get_previous_links(link_uuid):
    return simple_multi_value_query(models.MicroServiceChainLinkExitCode.objects.filter(nextmicroservicechainlink=link_uuid, exitcode=0), 'microservicechainlink_id')

def get_link_property(link_uuid, property):
    return simple_value_query(models.MicroServiceChainLink.objects.filter(pk=link_uuid), property)

def get_task_property(task_uuid, property):
    return simple_value_query(models.TaskConfig.objects.filter(pk=task_uuid), property)

def get_task_type_property(task_type_uuid, property):
    return simple_value_query(models.TaskType.objects.filter(pk=task_type_uuid), property)

def get_std_task_config_property(config_uuid, property):
    return simple_value_query(models.StandardTaskConfig.objects.filter(pk=config_uuid), property)

def get_link_default_next_link(link_uuid):
    return simple_value_query(models.MicroServiceChainLink.objects.filter(pk=link_uuid), 'defaultnextchainlink_id')

def get_link_default_next_link_and_prompt_if_nonexistant(link_uuid):
    if link_uuid is None:
        default_next_chain_link = None
    else:
        default_next_chain_link = get_link_default_next_link(link_uuid)

    if default_next_chain_link is None:
        print 'Enter the UUID of a link that should be processed if an error occurs (defaultNextChainLink): '
        return raw_input()

    return default_next_chain_link

def get_link_microservice_group(link_uuid):
    return simple_value_query(models.MicroServiceChainLink.objects.filter(pk=link_uuid), 'microservicegroup')

def link_exists(link_uuid):
    return simple_value_query(models.MicroServiceChainLink.objects.filter(pk=link_uuid), 'id') is not None

def link_for_display(link_uuid, indent=''):
    return indent + link_uuid + ' (' + get_link_task_description(link_uuid) + ')'

def get_link_task_description(link_uuid):
    task_config_uuid = simple_value_query(models.MicroServiceChainLink.objects.filter(pk=link_uuid), 'currenttask_id')
    return simple_value_query(models.TaskConfig.objects.filter(pk=task_config_uuid), 'description')

def get_chain_info(first_link):
    """ Returns (uuid, description) for the chain if it exists, given the first link."""
    try:
        chain = models.MicroServiceChain.objects.filter(startinglink=first_link)[0]
        return (chain.pk, chain.description)
    except IndexError:
        return (None, None)

def get_previous_links_lists(previous_link, previous_links_list, show_all_groups, microservice_group):
    while(previous_link != []):
        if len(previous_link) == 1:
            # Only one parent, process as normal
            previous_link = previous_link[0]
            previous_link_group = get_link_microservice_group(previous_link)
            if previous_link_group == microservice_group or show_all_groups:
                previous_links_list.insert(0, previous_link)
                previous_link = get_previous_links(previous_link)
            else:
                previous_link = []
        else:
            # Multiple parents - form nested structure of
            # [[parent list], [parent list], ...] through recursion
            parent_lists = []
            for link in previous_link:
                parent_list = get_previous_links_lists([link], [], show_all_groups, microservice_group)
                if parent_list != []:
                    parent_lists.insert(0, parent_list)
            previous_links_list.insert(0, parent_lists)
            # Terminate recursion for this function
            previous_link = []
    return previous_links_list

def print_nested_lists(nested_list, indent, show_all_groups):
    # print chain info
    if show_all_groups and nested_list and isinstance(nested_list[0], basestring):
        chain_uuid, chain_description = get_chain_info(nested_list[0])
        print "{}Chain {} ({})".format(indent[2:], chain_uuid, chain_description)
    for link in nested_list:
        if isinstance(link, list):
            print_nested_lists(link, indent+"  ", show_all_groups)
        elif isinstance(link, basestring):
            print link_for_display(link, indent)
        else:
            print indent+"Something went wrong"

def generate_standard_task_config_sql_from_user_input(standard_task_uuid):
    print 'Creating new standard task config entry SQL...'
    print 'Command? '
    command = raw_input()
    print 'Arguments? '
    arguments = raw_input()

    return """INSERT INTO StandardTasksConfigs (pk, requiresOutputLock, execute, arguments) VALUES ('%s', 0, '%s', '%s');""" % (standard_task_uuid, command, arguments)

def generate_task_config_sql_from_user_input(task_uuid, standard_task_uuid):
    print 'Creating new task entry SQL...'
    print 'Task type UUID (from TaskTypes table)? '
    task_type_uuid = raw_input()
    print 'Description? '
    description = raw_input()

    return """INSERT INTO TasksConfigs (pk, taskType, taskTypePKReference, description) VALUES ('%s', '%s', '%s', '%s');""" % (task_uuid, task_type_uuid, standard_task_uuid, description)

def generate_exit_code_sql_from_user_input(exit_code_uuid, link_uuid, next_link_uuid=None):

    if next_link_uuid is None:
        sql =  """INSERT INTO MicroServiceChainLinksExitCodes (pk, microServiceChainLink, exitCode, nextMicroServiceChainLink, exitMessage) VALUES ('%s', '%s', 0, NULL, 'Completed successfully');""" % (exit_code_uuid, link_uuid)
    else:
        sql = """INSERT INTO MicroServiceChainLinksExitCodes (pk, microServiceChainLink, exitCode, nextMicroServiceChainLink, exitMessage) VALUES ('%s', '%s', 0, '%s', 'Completed successfully');""" % (exit_code_uuid, link_uuid, next_link_uuid)
    return sql

#
# Command logic
#

def show_link_uuid_using_task_uuid(task_uuid):
    job_uuid = simple_value_query(models.Task.objects.filter(taskuuid=task_uuid), 'job_id')

    if job_uuid is None:
        print "ERROR: Task not found."
    else:
        link_uuid = simple_value_query(models.Job.objects.filter(jobuuid=job_uuid), 'microservicechainlink_id')

        if link_uuid is None:
            print "ERROR: Job for task not found."
        else:
            print "Link UUID: " + link_uuid

def show_link_uuid_using_job_uuid(job_uuid):
    link_uuid = simple_value_query(models.Job.objects.filter(jobuuid=job_uuid), 'microservicechainlink_id')

    if link_uuid is None:
        print "ERROR: Job not found."
    else:
        print "Link UUID: " + link_uuid

def show_link_chain_info(link_uuid):
    show_link_info(link_uuid, True)

def show_link_info(link_uuid, show_all_groups=False):
    if not link_exists(link_uuid):
        print 'ERROR: link UUID ' + link_uuid + ' does not exist.'
        return

    microservice_group = get_link_microservice_group(link_uuid)

    task_uuid = get_link_property(link_uuid, 'currenttask_id')
    task_type_uuid = get_task_property(task_uuid, 'tasktype_id')
    task_type = get_task_type_property(task_type_uuid, 'description')

    std_task_config_uuid = get_task_property(task_uuid, 'tasktypepkreference')
    std_task_execute = get_std_task_config_property(std_task_config_uuid, 'execute')
    std_task_arguments = get_std_task_config_property(std_task_config_uuid, 'arguments')

    task_type_description = 'Type: ' + task_type_uuid
    if task_type is not None:
        task_type_description = task_type_description + ', ' + task_type

    previous_links_list = []
    previous_link = get_previous_links(link_uuid)
    previous_links_list = get_previous_links_lists(previous_link, previous_links_list, show_all_groups, microservice_group)

    next_links = []
    next_link = get_next_link(link_uuid)
    while(next_link is not None):
        next_link_group = get_link_microservice_group(next_link)
        if next_link_group == microservice_group or show_all_groups:
            next_links.append(next_link)
            next_link = get_next_link(next_link)
        else:
            next_link = None

    indent = '  '

    print
    print 'Link ' + link_for_display(link_uuid)
    print '  Task ' + task_uuid + ' (' + task_type_description + ')'
    if std_task_config_uuid:
        print '  Std Task Config: ' + std_task_config_uuid
        print '    Execute: ' + str(std_task_execute)
        print '    Arguments: ' + str(std_task_arguments)
    print

    print 'Previous links: '
    print_nested_lists(previous_links_list, indent, show_all_groups)

    print

    print 'Next links: '
    for link in next_links:
        print link_for_display(link, indent)

def insert_link_before_link(link_uuid):
    if not link_exists(link_uuid):
        print 'ERROR: link UUID ' + link_uuid + ' does not exist.'
        return

    sql_commands = ''

    standard_task_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_standard_task_config_sql_from_user_input(standard_task_uuid) + "\n"

    task_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_task_config_sql_from_user_input(task_uuid, standard_task_uuid) + "\n"

    new_link_uuid = uuid.uuid4().__str__()
    links_before_target_link = get_previous_links(link_uuid)

    print 'Creating new link SQL...'
    print 'Microservice group? '
    microservice_group = raw_input()

    # add new link that will proceed to target link after normal execution
    default_next_link = get_link_default_next_link_and_prompt_if_nonexistant(link_uuid)
    sql = """INSERT INTO MicroServiceChainLinks(pk, microserviceGroup, defaultExitMessage, currentTask, defaultNextChainLink) values ('%s', '%s', 'Failed', '%s', '%s');""" % (new_link_uuid, microservice_group, task_uuid, default_next_link)
    sql_commands = sql_commands + sql + "\n"

    # add new exit code that will proceed to target link after normal execution
    exit_code_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_exit_code_sql_from_user_input(exit_code_uuid, new_link_uuid, link_uuid) + "\n"

    for link in links_before_target_link:
        # there is a link before our target link that we need to alter to point to our next link
        sql = """UPDATE MicroServiceChainLinksExitCodes SET nextMicroServiceChainLink='%s' WHERE microServiceChainLink='%s';""" % (new_link_uuid, link)
        sql_commands += sql + "\n"
    chain_uuid, _ = get_chain_info(link_uuid)
    if chain_uuid:
        # must update chain row to insert new link
        sql = """UPDATE MicroServiceChains SET startingLink='%s' WHERE pk='%s';""" % (new_link_uuid, chain_uuid)
        sql_commands += sql + "\n"

    print sql_commands

def insert_link_after_link(link_uuid):
    if not link_exists(link_uuid):
        print 'ERROR: link UUID ' + link_uuid + ' does not exist.'
        return

    sql_commands = ''

    standard_task_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_standard_task_config_sql_from_user_input(standard_task_uuid) + "\n"

    task_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_task_config_sql_from_user_input(task_uuid, standard_task_uuid) + "\n"

    new_link_uuid = uuid.uuid4().__str__()
    link_after_target_link = get_next_link(link_uuid)

    print 'Creating new link SQL...'
    print 'Microservice group? '
    microservice_group = raw_input()

    default_next_link = get_link_default_next_link_and_prompt_if_nonexistant(link_uuid)
    if link_after_target_link is None:
        sql = """INSERT INTO MicroServiceChainLinks(pk, microserviceGroup, defaultExitMessage, currentTask, defaultNextChainLink) values ('%s', '%s', 'Failed', '%s', '%s');""" % (new_link_uuid, microservice_group, task_uuid, default_next_link)
    else:
        sql = """INSERT INTO MicroServiceChainLinks(pk, microserviceGroup, defaultExitMessage, currentTask, defaultNextChainLink) values ('%s', '%s', 'Failed', '%s', '%s');""" % (new_link_uuid, microservice_group, task_uuid, default_next_link)
    sql_commands = sql_commands + sql + "\n"

    exit_code_uuid = uuid.uuid4().__str__()
    sql_commands = sql_commands + generate_exit_code_sql_from_user_input(exit_code_uuid, new_link_uuid, link_after_target_link) + "\n"

    sql = """UPDATE MicroServiceChainLinksExitCodes SET nextMicroServiceChainLink='%s' WHERE microServiceChainLink='%s';""" % (new_link_uuid, link_uuid)
    sql_commands = sql_commands + sql + "\n"

    # update target link to go to new link
    print sql_commands

def show_next(link_uuid):
    print "Next link UUID: " + str(get_next_link(link_uuid))

def show_previous(link_uuid):
    previous_uuids = get_previous_links(link_uuid)
    print "Previous link UUIDs: {0}".format(', '.join(previous_uuids))

#
# CLI interface
#

def help(parser, commands):
    parser.print_help()
    print
    print 'Commands:'
    for command in commands:
        print '  ' + commands[command]['usage'].ljust(28) + commands[command]['description']

if __name__ == '__main__':
    usage = "usage: %prog [options] <command>"

    parser = OptionParser(usage=usage)

    (options, args) = parser.parse_args()

    if len(args) > 0:
        # get command from first arg
        command = args.pop(0)
    else:
        command = ''

    # command definitions
    commands = {
        'linkfromtask': {
            'function':    show_link_uuid_using_task_uuid,
            'usage':       'linkfromtask <task UUID>',
            'description': "use task UUID to look up corresponding link's UUID"
        },
        'linkfromjob': {
            'function':    show_link_uuid_using_job_uuid,
            'usage':       'linkfromjob <job UUID>',
            'description': "use job UUID to look up corresponding link's UUID"
        },
        'info': {
            'function':    show_link_info,
            'usage':       'info <link UUID>',
            'description': 'show other links in the same microservice group'
        },
        'chaininfo': {
            'function':    show_link_chain_info,
            'usage':       'chaininfo <link UUID>',
            'description': 'show other links in the same chain'
        },
        'insertbefore': {
            'function':    insert_link_before_link,
            'usage':       'insertbefore <link UUID>',
            'description': 'insert a new link before an existing link'
        },
        'insertafter': {
            'function':    insert_link_after_link,
            'usage':       'insertafter <link UUID>',
            'description': 'insert a new link after an existing link'
        },
        'next': {
            'function':    show_next,
            'usage':       'next <link UUID>',
            'description': 'show the UUID of the next link in the chain'
        },
        'previous': {
            'function':    show_previous,
            'usage':       'previous <link UUID>',
            'description': 'show the UUID of the previous link in the chain'
        }
    }

    # execute command or show usage
    if command in commands:
        command_function = commands[command]['function']
        command_function(args.pop(0))
    else:
        help(parser, commands)
